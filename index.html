<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Benjamin Muschko">
<title>Testing Gradle plugins</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/css/asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/css/styles.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://guides.gradle.org/icon/manifest.json">
<link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico">
<meta name="apple-mobile-web-app-title" content="testing-gradle-plugins">
<meta name="application-name" content="testing-gradle-plugins">
<meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<script defer src="https://guides.gradle.org/js/set-time-to-complete-text.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script>
</head>
<body class="article toc2 toc-right">
<div id="header"><div style="padding-top: 10px;"><a href="https://guides.gradle.org"><img src="https://guides.gradle.org/gradle-guides.svg" alt=""></a></div><h1>Testing Gradle plugins</h1>
<div class="details">
<span id="author" class="author">Benjamin Muschko</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the_sample_project">1. The sample project</a></li>
<li><a href="#on_the_importance_of_testing">2. On the importance of testing</a>
<ul class="sectlevel2">
<li><a href="#testing-pyramid">2.1. The testing pyramid</a></li>
<li><a href="#tooling_support">2.2. Tooling support</a></li>
</ul>
</li>
<li><a href="#manual-tests">3. Setting up manual tests</a></li>
<li><a href="#setting_up_automated_tests">4. Setting up automated tests</a>
<ul class="sectlevel2">
<li><a href="#organizing_test_source_code">4.1. Organizing test source code</a></li>
<li><a href="#modeling_test_types">4.2. Modeling test types</a></li>
<li><a href="#configuring_a_test_framework">4.3. Configuring a test framework</a></li>
</ul>
</li>
<li><a href="#implementing_automated_tests">5. Implementing automated tests</a>
<ul class="sectlevel2">
<li><a href="#unit-tests">5.1. Implementing unit tests</a></li>
<li><a href="#integration-tests">5.2. Implementing integration tests</a></li>
<li><a href="#functional-tests">5.3. Implementing functional tests</a></li>
</ul>
</li>
<li><a href="#summary">6. Summary</a></li>
<li><a href="#next_steps">7. Next steps</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>With practice, writing Gradle plugins comes easy especially with the knowledge of the <a href="https://guides.gradle.org/implementing-gradle-plugins/">Implementing Gradle plugins</a> guide under your belt. Testing plays a crucial role in the development process as it ensures reliable and high-quality software. The same principles apply to build code and more specifically Gradle plugins. In this guide you will learn effective techniques for testing plugin code.</p>
</div>
<div class="paragraph">
<p>This guide assumes you have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic understanding of software engineering practices</p>
</li>
<li>
<p>Knowledge of Gradle plugin implementation techniques</p>
</li>
<li>
<p>Working knowledge in writing Java code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you happen to be a beginner to Gradle please start by working through the <a href="https://gradle.org/guides#getting-started">Getting Started Guides on Gradle development</a> first while referencing the <a href="https://docs.gradle.org/4.1/userguide/userguide.html">Gradle User Manual</a> to go deeper.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the_sample_project"><a class="anchor" href="#the_sample_project"></a>1. The sample project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All discussions in this guide are centered around a sample project called URL verifier plugin. The plugin creates a task named <code>verifyUrl</code> that checks whether a given URL can be resolved via HTTP GET. The end user can provide the URL via an extension named <code>verification</code>. To get familiar with the functionality of the plugin you can inspect the <a href="https://github.com/gradle-guides/testing-gradle-plugins/tree/master/samples/code/url-verifier-plugin">source code</a> on GitHub.</p>
</div>
<div class="paragraph">
<p>The following build script assumes that the plugin JAR file has been published to a binary repository. In a nutshell, the script demonstrates how to apply the plugin to the project and configure its exposed extension.</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.urlverifier</span><span class="delimiter">'</span></span>   <i class="conum" data-value="1"></i><b>(1)</b>

verification {                                  <i class="conum" data-value="2"></i><b>(2)</b>
    url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.google.com/</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Applies the plugin to the project</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configures the URL to be verified through the exposed extension</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Executing the task renders a success message if the HTTP GET call to the configured URL returns with a 200 response code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">$ gradle verifyUrl

&gt; Task :verifyUrl
Successfully resolved URL 'http://www.google.com/'

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before diving into the code, let&#8217;s first revisit the different types of tests and the tooling that supports implementing them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="on_the_importance_of_testing"><a class="anchor" href="#on_the_importance_of_testing"></a>2. On the importance of testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Testing is a foundational activity in the software development lifecycle. Appropriate testing ensures that the software works on a functional and non-functional level before it is released to the end user. As a by product, automated testing also enables the development team to refactor and evolve the code without fearing to introduce regressions in the process.</p>
</div>
<div class="sect2">
<h3 id="testing-pyramid"><a class="anchor" href="#testing-pyramid"></a>2.1. The testing pyramid</h3>
<div class="imageblock" style="float: right">
<div class="content">
<img src="images/testing-pyramid.png" alt="testing pyramid">
</div>
</div>
<div class="paragraph">
<p>Probably the easiest way to test software is to manually exercise it. <strong>Manual testing</strong> can occur at any time and is not bound to writing automation code. However, manual testing is error-prone and cumbersome as it requires a human to walk through a set of predefined test cases. Manually testing Gradle plugins usually requires publishing the binary artifact to a repository and consuming it from a build script.</p>
</div>
<div class="paragraph">
<p>Other types of tests can be fully automated and exercised with every change to the source code. The testing pyramid introduced by Mike Cohen in his book <a href="https://www.mountaingoatsoftware.com/books/succeeding-with-agile-software-development-using-scrum">Succeeding with Agile: Software Development Using Scrum</a> describes three types of automated tests.</p>
</div>
<div class="paragraph">
<p><strong>Unit testing</strong> aims to verify the smallest unit of code. In Java-based projects this unit is a method. Unit tests usually do not interact with other parts of the system e.g. a database or the file system. Interactions with other parts of the system are usually cut off with the help of Stubs or Mocks. You will find that POJOs and utility classes are good candidates for unit tests as they are self-contained and do not use the Gradle API.</p>
</div>
<div class="paragraph">
<p><strong>Integration testing</strong> verifies that multiple classes or components work together as a whole. The code under test may reach out to external subsystems or use the Gradle API.</p>
</div>
<div class="paragraph">
<p><strong>Functional testing</strong> is used to test the system from the end user&#8217;s perspective. End-to-end tests for Gradle plugins stand up a build script, apply the plugin under test and execute the build with a specific task. The outcome of the build (e.g. standard output/error or generated artifacts) verifies the correctness of the functionality.</p>
</div>
</div>
<div class="sect2">
<h3 id="tooling_support"><a class="anchor" href="#tooling_support"></a>2.2. Tooling support</h3>
<div class="paragraph">
<p>Implementing manual and automated testing for Gradle plugins is straight forward - it just requires the right tooling. The table below gives you a brief overview on how to approach each test type. Please be aware that you have the free choice of using the test framework you are most familiar with. For a detailed discussion and code example please refer to the dedicated section in this guide.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Test type</th>
<th class="tableblock halign-left valign-top">Tooling support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#manual-tests">Manual tests</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/4.1/userguide/composite_builds.html">Gradle composite builds</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#unit-tests">Unit tests</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any JVM-based test framework</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#integration-tests">Integration tests</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any JVM-based test framework and <a href="https://docs.gradle.org/4.1/javadoc/org/gradle/testfixtures/ProjectBuilder.html">Gradle&#8217;s ProjectBuilder API</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#functional-tests">Functional tests</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any JVM-based test framework and <a href="https://docs.gradle.org/4.1/userguide/test_kit.html">Gradle TestKit</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manual-tests"><a class="anchor" href="#manual-tests"></a>3. Setting up manual tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The typical way to manually test a Gradle plugin follows this workflow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make a change to the plugin code.</p>
</li>
<li>
<p>Publish a new version of the plugin artifact to a local repository.</p>
</li>
<li>
<p>Resolve the plugin from the repository and apply it to a sample project.</p>
</li>
<li>
<p>Rinse and repeat.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Granted this technique is cumbersome - every change to the plugin code requires the developer to publish a new version of the artifact. With the introduction of the <a href="https://docs.gradle.org/4.1/userguide/composite_builds.html">composite builds</a> feature, plugin developers have a more convenient and powerful mechanism at their disposal. The standalone plugin project and the consuming project can be combined together into a single unit making it much more straight forward to try out or debug changes without the hassle of re-publishing the binary file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.
├── include-plugin-build   <i class="conum" data-value="1"></i><b>(1)</b>
│   ├── build.gradle
│   └── settings.gradle
└── url-verifier-plugin    <i class="conum" data-value="2"></i><b>(2)</b>
    ├── build.gradle
    ├── settings.gradle
    └── src</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Consuming project that includes the plugin project</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The plugin project</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two ways to include a plugin project into a consuming project.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>By using the command line option <code>--include-build</code>.</p>
</li>
<li>
<p>By using the method <code>includeBuild</code> in <code>settings.gradle</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following code snippet demonstrates the use of the settings file.</p>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">includeBuild <span class="string"><span class="delimiter">'</span><span class="content">../url-verifier-plugin</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of the project <code>include-plugin-build</code> in plain console mode clearly shows that the plugin project became part of a multi-project build.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">$ gradle verifyUrl --console=plain

:url-verifier-plugin:compileJava
:url-verifier-plugin:compileGroovy NO-SOURCE
:url-verifier-plugin:pluginDescriptors
:url-verifier-plugin:processResources
:url-verifier-plugin:classes
:url-verifier-plugin:jar
:verifyUrl
Successfully resolved URL 'http://www.google.com/'

BUILD SUCCESSFUL in 1s
1 actionable task: 1 executed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Manual testing has its place in the development process. By no means it is a replacement for automated testing. Next up, you&#8217;ll learn how to organize and implement automated tests for Gradle plugins.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting_up_automated_tests"><a class="anchor" href="#setting_up_automated_tests"></a>4. Setting up automated tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Setting up a suite of tests earlier on is crucial to the success of your plugin. You will encounter various situations that make your tests an invaluable safety net you can rely on e.g. when upgrading the plugin to a new Gradle version and enhancing or refactoring the code.</p>
</div>
<div class="sect2">
<h3 id="organizing_test_source_code"><a class="anchor" href="#organizing_test_source_code"></a>4.1. Organizing test source code</h3>
<div class="paragraph">
<p>It is recommended to implement a good distribution of unit, integration and functional tests to cover the most important use cases. Separating the source code for each test type automatically results in a project that is more maintainable and manageable.</p>
</div>
<div class="paragraph">
<p>By default the Java project already creates a convention for organizing unit tests, the directory <code>src/test/java</code>. Additionally, if you apply the Groovy plugin source code under the directory <code>src/test/groovy</code> is taken under consideration for compilation. Consequently, source code directories for other test types should follow a similar pattern. Below you can find an exemplary project layout for a plugin project that chooses to use a Groovy-based testing approach.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.
└── src
    ├── functTest
    │   └── groovy      <i class="conum" data-value="1"></i><b>(1)</b>
    ├── integTest
    │   └── groovy      <i class="conum" data-value="2"></i><b>(2)</b>
    ├── main
    │   ├── java        <i class="conum" data-value="3"></i><b>(3)</b>
    │   └── resources   <i class="conum" data-value="4"></i><b>(4)</b>
    └── test
        └── groovy      <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Source directory containing functional tests</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Source directory containing integration tests</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Source directory containing production source code</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Source directory containing production resource files</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Source directory containing unit tests</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The directories <code>src/integTest/groovy</code> and <code>src/functTest/groovy</code> are not based on an existing standard convention for Gradle projects. You can free to choose any project layout that works best for you.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the next section, you will learn how to configure those source directories for compilation and test execution.</p>
</div>
</div>
<div class="sect2">
<h3 id="modeling_test_types"><a class="anchor" href="#modeling_test_types"></a>4.2. Modeling test types</h3>
<div class="paragraph">
<p>Gradle models source code directories with the help of the <a href="https://docs.gradle.org/4.1/userguide/java_plugin.html#sec:working_with_java_source_sets">source set concept</a>. By pointing an instance of a source set to one or many source code directories, Gradle will automatically create a corresponding compilation task out-of-the-box. The following script plugin demonstrates the creation of a source set for integration tests.</p>
</div>
<div class="listingblock">
<div class="title">integration-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    integrationTest {
        groovy.srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/integTest/groovy</span><span class="delimiter">'</span></span>)
        resources.srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/integTest/resources</span><span class="delimiter">'</span></span>)
        compileClasspath += sourceSets.main.output + configurations.testRuntime
        runtimeClasspath += output + compileClasspath
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Source sets are only responsible for compiling source code but do not deal with executing the byte code. For the purpose of test execution, a corresponding task of type <a href="https://docs.gradle.org/4.1/javadoc/org/gradle/api/tasks/testing/Test.html">Test</a> needs to be established. The following task demonstrate the setup for executing integration tests. As you can see below, the task references the classes and runtime classpath of the integration test source set.</p>
</div>
<div class="listingblock">
<div class="title">integration-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task integrationTest(<span class="key">type</span>: Test) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">Runs the integration tests.</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">verification</span><span class="delimiter">'</span></span>
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    mustRunAfter test
}

check.dependsOn integrationTest</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring_a_test_framework"><a class="anchor" href="#configuring_a_test_framework"></a>4.3. Configuring a test framework</h3>
<div class="paragraph">
<p>Gradle does not dictate the use of a specific test framework. Popular choices include <a href="http://junit.org/junit4/">JUnit</a>, <a href="http://testng.org/">TestNG</a> and <a href="http://spockframework.org/">Spock</a>. Once you choose an option, you have to add its dependency to the compile classpath for your tests. The following code snippet shows how to use Spock for implementing tests.</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
}

dependencies {
    testCompile(<span class="string"><span class="delimiter">'</span><span class="content">org.spockframework:spock-core:1.1-groovy-2.4</span><span class="delimiter">'</span></span>) {
        exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spock is a Groovy-based BDD test framework that even includes APIs for creating Stubs and Mocks. The Gradle team prefers Spock over other options for its expressiveness and conciseness.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementing_automated_tests"><a class="anchor" href="#implementing_automated_tests"></a>5. Implementing automated tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses representative implementation examples for unit, integration and functional tests. All test classes are based on the use of Spock though it should be relatively easy to adapt the code to a different test framework. You can find all classes in the <a href="https://github.com/gradle-guides/testing-gradle-plugins/tree/master/samples/code/url-verifier-plugin">source code repository for this guide</a>. Please revisit the section <a href="#testing-pyramid">the testing pyramid</a> for a formal discussion of the definition of each test type.</p>
</div>
<div class="sect2">
<h3 id="unit-tests"><a class="anchor" href="#unit-tests"></a>5.1. Implementing unit tests</h3>
<div class="paragraph">
<p>The URL verifier plugin emits HTTP GET calls to check if a URL can be resolved successfully. The method <code>DefaultHttpCaller.get(String)</code> is responsible for calling a given URL and returns with an instance of type <code>HttpResponse</code>. <code>HttpResponse</code> is a POJO containing information about the HTTP response code and message.</p>
</div>
<div class="listingblock">
<div class="title">HttpResponse.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.gradle.sample.http</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">HttpResponse</span> {
    <span class="directive">private</span> <span class="type">int</span> code;
    <span class="directive">private</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> HttpResponse(<span class="type">int</span> code, <span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.code = code;
        <span class="local-variable">this</span>.message = message;
    }

    <span class="directive">public</span> <span class="type">int</span> getCode() {
        <span class="keyword">return</span> code;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getMessage() {
        <span class="keyword">return</span> message;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">HTTP </span><span class="delimiter">&quot;</span></span> + code + <span class="string"><span class="delimiter">&quot;</span><span class="content">, Reason: </span><span class="delimiter">&quot;</span></span> + message;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>HttpResponse</code> represents a good candidate to be tested by a unit test. It does not reach out to any other classes nor does it use the Gradle API.</p>
</div>
<div class="listingblock">
<div class="title">HttpResponseTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> org.gradle.sample.http

<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>

<span class="type">class</span> <span class="class">HttpResponseTest</span> <span class="directive">extends</span> Specification {

    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> OK_HTTP_CODE = <span class="integer">200</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> OK_HTTP_MESSAGE = <span class="string"><span class="delimiter">'</span><span class="content">OK</span><span class="delimiter">'</span></span>

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can access information</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        <span class="keyword">def</span> httpResponse = <span class="keyword">new</span> HttpResponse(OK_HTTP_CODE, OK_HTTP_MESSAGE)

        <span class="key">then</span>:
        httpResponse.code == OK_HTTP_CODE
        httpResponse.message == OK_HTTP_MESSAGE
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can get String representation</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        <span class="keyword">def</span> httpResponse = <span class="keyword">new</span> HttpResponse(OK_HTTP_CODE, OK_HTTP_MESSAGE)

        <span class="key">then</span>:
        httpResponse.toString() == <span class="string"><span class="delimiter">&quot;</span><span class="content">HTTP </span><span class="inline"><span class="inline-delimiter">$</span>OK_HTTP_CODE</span><span class="content">, Reason: </span><span class="inline"><span class="inline-delimiter">$</span>OK_HTTP_MESSAGE</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-tests"><a class="anchor" href="#integration-tests"></a>5.2. Implementing integration tests</h3>
<div class="paragraph">
<p>Integration tests might or might not use the Gradle API. This section of the guide explains solutions for both situations.</p>
</div>
<div class="sect3">
<h4 id="class_under_test_does_not_use_gradle_api"><a class="anchor" href="#class_under_test_does_not_use_gradle_api"></a>5.2.1. Class under test does not use Gradle API</h4>
<div class="paragraph">
<p>First, we&#8217;ll have a look at a class that reaches out to a another system, the piece of code that emits the HTTP calls. At the time of executing a test for the class <code>DefaultHttpCaller</code>, the runtime environment needs to be able to reach out to the internet.</p>
</div>
<div class="listingblock">
<div class="title">DefaultHttpCaller.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.gradle.sample.http</span>;

<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">java.net.HttpURLConnection</span>;
<span class="keyword">import</span> <span class="include">java.net.URL</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultHttpCaller</span> <span class="directive">implements</span> HttpCaller {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> HttpResponse get(<span class="predefined-type">String</span> url) {
        <span class="keyword">try</span> {
            <span class="predefined-type">HttpURLConnection</span> connection = (<span class="predefined-type">HttpURLConnection</span>) <span class="keyword">new</span> <span class="predefined-type">URL</span>(url).openConnection();
            connection.setConnectTimeout(<span class="integer">5000</span>);
            connection.setRequestMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>);
            connection.connect();

            <span class="type">int</span> code = connection.getResponseCode();
            <span class="predefined-type">String</span> message = connection.getResponseMessage();
            <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(code, message);
        } <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> HttpCallException(<span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to call URL '%s' via HTTP GET</span><span class="delimiter">&quot;</span></span>, url), e);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementing an integration test for <code>DefaultHttpCaller</code> doesn&#8217;t look much different from the unit test shown in the previous section.</p>
</div>
<div class="listingblock">
<div class="title">DefaultHttpCallerIntegrationTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> org.gradle.sample.http

<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>
<span class="keyword">import</span> <span class="include">spock.lang.Subject</span>

<span class="type">class</span> <span class="class">DefaultHttpCallerIntegrationTest</span> <span class="directive">extends</span> Specification {
    <span class="annotation">@Subject</span> HttpCaller httpCaller = <span class="keyword">new</span> DefaultHttpCaller()

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can make successful HTTP GET call</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        <span class="keyword">def</span> httpResponse = httpCaller.get(<span class="string"><span class="delimiter">'</span><span class="content">http://www.google.com/</span><span class="delimiter">'</span></span>)

        <span class="key">then</span>:
        httpResponse.code == <span class="integer">200</span>
        httpResponse.message == <span class="string"><span class="delimiter">'</span><span class="content">OK</span><span class="delimiter">'</span></span>
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">throws exception when calling unknown host via HTTP GET</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        httpCaller.get(<span class="string"><span class="delimiter">'</span><span class="content">http://www.wedonotknowyou123.com/</span><span class="delimiter">'</span></span>)

        <span class="key">then</span>:
        <span class="keyword">def</span> t = thrown(HttpCallException)
        t.message == <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to call URL 'http://www.wedonotknowyou123.com/' via HTTP GET</span><span class="delimiter">&quot;</span></span>
        t.cause <span class="keyword">instanceof</span> <span class="exception">UnknownHostException</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="class_under_test_uses_gradle_api"><a class="anchor" href="#class_under_test_uses_gradle_api"></a>5.2.2. Class under test uses Gradle API</h4>
<div class="paragraph">
<p>The task implementation responsible for verifying a URL is a more interesting example as it requires a dependency on the Gradle API.</p>
</div>
<div class="listingblock">
<div class="title">UrlVerify.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.gradle.sample.tasks</span>;

<span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.GradleException</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.provider.PropertyState</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.provider.Provider</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>;
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.DefaultHttpCaller</span>;
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpCallException</span>;
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpCaller</span>;
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpResponse</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">UrlVerify</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">private</span> HttpCaller httpCaller = <span class="keyword">new</span> DefaultHttpCaller();
    <span class="directive">private</span> <span class="directive">final</span> PropertyState&lt;<span class="predefined-type">String</span>&gt; url;

    <span class="directive">public</span> UrlVerify() {
        <span class="local-variable">this</span>.url = getProject().property(<span class="predefined-type">String</span>.class);
    }

    <span class="directive">public</span> <span class="type">void</span> setUrl(<span class="predefined-type">String</span> url) {
        <span class="local-variable">this</span>.url.set(url);
    }

    <span class="directive">public</span> <span class="type">void</span> setUrl(<span class="predefined-type">Provider</span>&lt;<span class="predefined-type">String</span>&gt; url) {
        <span class="local-variable">this</span>.url.set(url);
    }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getUrl() {
        <span class="keyword">return</span> url.get();
    }

    <span class="annotation">@TaskAction</span>
    <span class="directive">public</span> <span class="type">void</span> verify() {
        <span class="keyword">try</span> {
            HttpResponse httpResponse = httpCaller.get(getUrl());

            <span class="keyword">if</span> (httpResponse.getCode() != <span class="integer">200</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to resolve url '%s' (%s)</span><span class="delimiter">&quot;</span></span>, getUrl(), httpResponse.toString()));
            }
        } <span class="keyword">catch</span> (HttpCallException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to resolve url '%s'</span><span class="delimiter">&quot;</span></span>, getUrl(), e));
        }

        getLogger().quiet(<span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">Successfully resolved URL '%s'</span><span class="delimiter">&quot;</span></span>, getUrl()));
    }

    <span class="type">void</span> setHttpCaller(HttpCaller httpCaller) {
        <span class="local-variable">this</span>.httpCaller = httpCaller;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creating a task in an integration test requires a reference to the <code>Project</code> instance. To be able to use the <code>ProjectBuilder</code> API the test setup needs to declare a reference to the Gradle API.</p>
</div>
<div class="listingblock">
<div class="title">integration-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    integrationTestCompile gradleApi()
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The created <code>Project</code> instance acts as a stand-in object that <em>almost</em> behaves like a real instance. There are certain limitations for this <code>Project</code> instance e.g. it doesn&#8217;t automatically invoke project lifecycle hooks like <code>afterEvaluate</code>. If you happen to run into those limitations then writing a <a href="#functional-tests">functional test</a> is likely the better option. In the long run, <code>ProjectBuilder</code> might become a more powerful API.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following integration test demonstrates the use of <code>ProjectBuilder</code>. The <code>setup</code> method first creates a <code>Project</code> instance. From the <code>Project</code>, the test creates a task of type <code>UrlVerify</code>. Any HTTP communication has been mocked. All test cases can solely concentrate on verifying the correct behavior of the task implementation.</p>
</div>
<div class="listingblock">
<div class="title">UrlVerifyIntegrationTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> org.gradle.sample.tasks

<span class="keyword">import</span> <span class="include">org.gradle.api.GradleException</span>
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpCallException</span>
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpCaller</span>
<span class="keyword">import</span> <span class="include">org.gradle.sample.http.HttpResponse</span>
<span class="keyword">import</span> <span class="include">org.gradle.testfixtures.ProjectBuilder</span>
<span class="keyword">import</span> <span class="include">org.junit.Rule</span>
<span class="keyword">import</span> <span class="include">org.junit.rules.TemporaryFolder</span>
<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>
<span class="keyword">import</span> <span class="include">spock.lang.Subject</span>

<span class="type">class</span> <span class="class">UrlVerifyIntegrationTest</span> <span class="directive">extends</span> Specification {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> EXAMPLE_URL = <span class="string"><span class="delimiter">'</span><span class="content">http://www.google.com/</span><span class="delimiter">'</span></span>

    <span class="annotation">@Rule</span> TemporaryFolder temporaryFolder = <span class="keyword">new</span> TemporaryFolder()
    <span class="annotation">@Subject</span> UrlVerify verifyUrlTask
    <span class="keyword">def</span> httpCaller = Mock(HttpCaller)

    <span class="keyword">def</span> <span class="function">setup</span>() {
        <span class="keyword">def</span> project = ProjectBuilder.builder().withProjectDir(temporaryFolder.root).build()
        verifyUrlTask = project.tasks.create(<span class="string"><span class="delimiter">'</span><span class="content">verifyUrl</span><span class="delimiter">'</span></span>, UrlVerify)
        verifyUrlTask.httpCaller = httpCaller
        verifyUrlTask.url = EXAMPLE_URL
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can successfully resolve URL</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        verifyUrlTask.verify()

        <span class="key">then</span>:
        <span class="integer">1</span> * httpCaller.get(EXAMPLE_URL) &gt;&gt; <span class="keyword">new</span> HttpResponse(<span class="integer">200</span>, <span class="string"><span class="delimiter">'</span><span class="content">OK</span><span class="delimiter">'</span></span>)
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">throws exception when resolving URL for status code other than 200</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        verifyUrlTask.verify()

        <span class="key">then</span>:
        <span class="integer">1</span> * httpCaller.get(EXAMPLE_URL) &gt;&gt; <span class="keyword">new</span> HttpResponse(<span class="integer">500</span>, <span class="string"><span class="delimiter">'</span><span class="content">Internal Server Error</span><span class="delimiter">'</span></span>)
        <span class="keyword">def</span> t = thrown(GradleException)
        t.message == <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to resolve url 'http://www.google.com/' (HTTP 500, Reason: Internal Server Error)</span><span class="delimiter">&quot;</span></span>
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">rethrows exception when failing to resolve URL</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">when</span>:
        verifyUrlTask.verify()

        <span class="key">then</span>:
        <span class="integer">1</span> * httpCaller.get(EXAMPLE_URL) &gt;&gt; { <span class="keyword">throw</span> <span class="keyword">new</span> HttpCallException(<span class="string"><span class="delimiter">'</span><span class="content">unknown host</span><span class="delimiter">'</span></span>) }
        <span class="keyword">def</span> t = thrown(GradleException)
        t.message == <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to resolve url 'http://www.google.com/'</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="functional-tests"><a class="anchor" href="#functional-tests"></a>5.3. Implementing functional tests</h3>
<div class="paragraph">
<p>Functional tests verify the correctness of the plugin end-to-end. In practice that means applying, configuring and executing the functionality of the plugin implementation represented by the class <code>UrlVerifierPlugin</code>. As you can see, the implementation exposes an extension and a task instance that uses the URL value configured by the end user.</p>
</div>
<div class="listingblock">
<div class="title">UrlVerifierPlugin.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.gradle.sample</span>;

<span class="keyword">import</span> <span class="include">org.gradle.api.Plugin</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.Project</span>;
<span class="keyword">import</span> <span class="include">org.gradle.sample.tasks.UrlVerify</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">UrlVerifierPlugin</span> <span class="directive">implements</span> Plugin&lt;Project&gt; {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> apply(Project project) {
        UrlVerifierExtension extension = project.getExtensions().create(<span class="string"><span class="delimiter">&quot;</span><span class="content">verification</span><span class="delimiter">&quot;</span></span>, UrlVerifierExtension.class, project);
        UrlVerify verifyUrlTask = project.getTasks().create(<span class="string"><span class="delimiter">&quot;</span><span class="content">verifyUrl</span><span class="delimiter">&quot;</span></span>, UrlVerify.class);
        verifyUrlTask.setUrl(extension.getUrlProvider());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every Gradle plugin project should apply the <a href="https://docs.gradle.org/4.1/userguide/javaGradle_plugin.html">plugin development plugin</a> to reduce boilerplate code. By applying the plugin development plugin, the project is preconfigured for the use of TestKit. Let&#8217;s point the plugin to the custom source set containing functional tests.</p>
</div>
<div class="listingblock">
<div class="title">functional-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gradlePlugin {
    testSourceSets sourceSets.functionalTest
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Functional tests for Gradle plugins use a instance of <code>GradleRunner</code> to execute the build under test. <code>GradleRunner</code> is an API provided by TestKit which internally uses the Tooling API to execute the build. The following example applies the plugin to the build script under test, configures the extension and executes the build with the task <code>verifyUrl</code>. Please see the <a href="https://docs.gradle.org/4.1/userguide/test_kit.html">TestKit documentation</a> to get more familiar with the functionality of TestKit.</p>
</div>
<div class="listingblock">
<div class="title">UrlVerifierPluginFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> org.gradle.sample

<span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.GradleRunner</span>
<span class="keyword">import</span> <span class="include">org.junit.Rule</span>
<span class="keyword">import</span> <span class="include">org.junit.rules.TemporaryFolder</span>
<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>

<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.gradle.testkit.runner.TaskOutcome.SUCCESS</span>

<span class="type">class</span> <span class="class">UrlVerifierPluginFunctionalTest</span> <span class="directive">extends</span> Specification {
    <span class="annotation">@Rule</span> TemporaryFolder testProjectDir = <span class="keyword">new</span> TemporaryFolder()
    <span class="predefined-type">File</span> buildFile

    <span class="keyword">def</span> <span class="function">setup</span>() {
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)
        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            plugins {
                id 'org.gradle.sample.urlverifier'
            }
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can successfully configure URL through extension and verify it</span><span class="delimiter">&quot;</span></span>() {
        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            verification {
                url = 'http://www.google.com/'
            }
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>

        <span class="key">when</span>:
        <span class="keyword">def</span> result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">verifyUrl</span><span class="delimiter">'</span></span>)
            .withPluginClasspath()
            .build()

        <span class="key">then</span>:
        result.output.contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">Successfully resolved URL 'http://www.google.com/'</span><span class="delimiter">&quot;</span></span>)
        result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:verifyUrl</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>6. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Please let us know on the <a href="https://discuss.gradle.org/">Gradle forum</a> if you are still having difficulties understanding any of the covered testing strategies. Which one works the best for your plugin? Let us know!</p>
</div>
<div class="paragraph">
<p>Wrote an awesome plugin? Write a tweet to <a href="https://twitter.com/gradle">@gradle</a> with the link to the documentation or code.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="next_steps"><a class="anchor" href="#next_steps"></a>7. Next steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Testing Gradle plugins builds upon best practices and development strategies. You may be interested in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://guides.gradle.org/designing-gradle-plugins/">Designing Gradle plugins</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/implementing-gradle-plugins/">Implementing Gradle plugins</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-08-15 16:55:49 +00:00
</div>
</div>
</body>
</html>